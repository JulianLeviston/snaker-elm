---
phase: 02-frontend-migration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - assets/elm.json
  - assets/src/Main.elm
  - assets/src/Ports.elm
  - assets/src/Game.elm
  - assets/src/Snake.elm
  - assets/src/Input.elm
  - assets/js/app.ts
autonomous: true

must_haves:
  truths:
    - "Elm compiles without errors"
    - "Browser shows Elm application initialized"
    - "Arrow keys and WASD change direction (logged to console)"
  artifacts:
    - path: "assets/elm.json"
      provides: "Elm 0.19.1 project configuration"
      contains: '"elm-version": "0.19.1"'
    - path: "assets/src/Main.elm"
      provides: "Browser.element entry point"
      contains: "Browser.element"
    - path: "assets/src/Ports.elm"
      provides: "Port definitions for JS interop"
      contains: "port module"
    - path: "assets/src/Input.elm"
      provides: "Keyboard input handling"
      contains: "Browser.Events.onKeyDown"
    - path: "assets/src/Game.elm"
      provides: "Game state types"
      contains: "type alias GameState"
    - path: "assets/src/Snake.elm"
      provides: "Snake types"
      contains: "type alias Snake"
  key_links:
    - from: "assets/src/Main.elm"
      to: "assets/src/Ports.elm"
      via: "import"
      pattern: "import Ports"
    - from: "assets/src/Main.elm"
      to: "assets/src/Input.elm"
      via: "keyboard subscription"
      pattern: "Input\\.keyDecoder"
    - from: "assets/js/app.ts"
      to: "assets/src/Main.elm"
      via: "Elm.Main.init"
      pattern: "Elm\\.Main\\.init"
---

<objective>
Create fresh Elm 0.19.1 application with Browser.element, port definitions, and keyboard input handling.

Purpose: This is a clean slate Elm 0.19 project (not migration). The old Elm 0.18 code will be deleted after this phase is complete. This plan establishes the Elm application structure that will communicate with the Phoenix backend via ports.

Output: Compiling Elm application with keyboard input that logs direction changes, ready for WebSocket integration.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-frontend-migration/02-RESEARCH.md
@.planning/phases/02-frontend-migration/02-CONTEXT.md
@.planning/phases/02-frontend-migration/02-01-SUMMARY.md
@lib/snaker_web/channels/game_channel.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Elm 0.19.1 project with dependencies</name>
  <files>
    assets/elm.json
    assets/src/Main.elm
  </files>
  <action>
1. Create assets/src/ directory for Elm source files

2. Create elm.json in assets/ directory (NOT in elm/ subdirectory):
```json
{
    "type": "application",
    "source-directories": ["src"],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/time": "1.0.0"
        },
        "indirect": {
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
```

3. Create minimal Main.elm with Browser.element:
```elm
module Main exposing (main)

import Browser
import Html exposing (Html, div, text)
import Html.Attributes exposing (class)


type alias Model =
    { message : String
    }


type Msg
    = NoOp


init : () -> ( Model, Cmd Msg )
init _ =
    ( { message = "Elm 0.19.1 initialized!" }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp ->
            ( model, Cmd.none )


view : Model -> Html Msg
view model =
    div [ class "game-container" ]
        [ text model.message
        ]


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
```

4. Test Elm compiles:
```bash
cd assets && elm make src/Main.elm --output=/dev/null
```
  </action>
  <verify>
    cd /Users/julian/code/elm/snaker-elm/assets && elm make src/Main.elm --output=/dev/null 2>&1
  </verify>
  <done>
    elm make succeeds with "Success!" message, no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create port module and game types</name>
  <files>
    assets/src/Ports.elm
    assets/src/Game.elm
    assets/src/Snake.elm
  </files>
  <action>
1. Create Ports.elm with port definitions matching server message format:
```elm
port module Ports exposing
    ( joinGame
    , leaveGame
    , sendDirection
    , receiveGameState
    , receiveError
    , playerJoined
    , playerLeft
    , receiveTick
    )

import Json.Decode as JD
import Json.Encode as JE


-- Outgoing ports (Commands to JS)

port joinGame : JE.Value -> Cmd msg

port leaveGame : () -> Cmd msg

port sendDirection : JE.Value -> Cmd msg


-- Incoming ports (Subscriptions from JS)

port receiveGameState : (JD.Value -> msg) -> Sub msg

port receiveError : (String -> msg) -> Sub msg

port playerJoined : (JD.Value -> msg) -> Sub msg

port playerLeft : (JD.Value -> msg) -> Sub msg

port receiveTick : (JD.Value -> msg) -> Sub msg
```

2. Create Snake.elm with snake types matching server format:
```elm
module Snake exposing
    ( Snake
    , Position
    , Direction(..)
    , directionToString
    , decoder
    , positionDecoder
    )

import Json.Decode as JD


type Direction
    = Up
    | Down
    | Left
    | Right


type alias Position =
    { x : Int
    , y : Int
    }


type alias Snake =
    { id : String
    , body : List Position
    , direction : Direction
    , color : String
    }


directionToString : Direction -> String
directionToString dir =
    case dir of
        Up -> "up"
        Down -> "down"
        Left -> "left"
        Right -> "right"


positionDecoder : JD.Decoder Position
positionDecoder =
    JD.map2 Position
        (JD.field "x" JD.int)
        (JD.field "y" JD.int)


directionDecoder : JD.Decoder Direction
directionDecoder =
    JD.string
        |> JD.andThen
            (\str ->
                case str of
                    "up" -> JD.succeed Up
                    "down" -> JD.succeed Down
                    "left" -> JD.succeed Left
                    "right" -> JD.succeed Right
                    _ -> JD.fail ("Unknown direction: " ++ str)
            )


decoder : JD.Decoder Snake
decoder =
    JD.map4 Snake
        (JD.field "id" JD.string)
        (JD.field "body" (JD.list positionDecoder))
        (JD.field "direction" directionDecoder)
        (JD.field "color" JD.string)
```

3. Create Game.elm with game state types:
```elm
module Game exposing
    ( GameState
    , Apple
    , Player
    , decoder
    , appleDecoder
    , playerDecoder
    )

import Json.Decode as JD
import Snake exposing (Snake, Position)


type alias Apple =
    { position : Position
    }


type alias Player =
    { id : String
    , snake : Snake
    }


type alias GameState =
    { snakes : List Snake
    , apples : List Apple
    , gridWidth : Int
    , gridHeight : Int
    }


appleDecoder : JD.Decoder Apple
appleDecoder =
    JD.map Apple
        (JD.field "position" Snake.positionDecoder)


playerDecoder : JD.Decoder Player
playerDecoder =
    JD.map2 Player
        (JD.field "id" JD.string)
        (JD.field "snake" Snake.decoder)


decoder : JD.Decoder GameState
decoder =
    JD.map4 GameState
        (JD.field "snakes" (JD.list Snake.decoder))
        (JD.field "apples" (JD.list appleDecoder))
        (JD.field "grid_width" JD.int)
        (JD.field "grid_height" JD.int)
```

4. Verify all modules compile:
```bash
cd assets && elm make src/Main.elm --output=/dev/null
```
  </action>
  <verify>
    cd /Users/julian/code/elm/snaker-elm/assets && elm make src/Main.elm --output=/dev/null 2>&1
  </verify>
  <done>
    All Elm files compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add keyboard input handling and wire to Main</name>
  <files>
    assets/src/Input.elm
    assets/src/Main.elm
    assets/js/app.ts
  </files>
  <action>
1. Create Input.elm with keyboard handling using Browser.Events:
```elm
module Input exposing
    ( keyDecoder
    , Direction(..)
    )

import Json.Decode as JD
import Snake exposing (Direction(..))


{-| Decode keyboard events to direction changes.
Handles both Arrow keys and WASD.
Ignores key repeat events.
-}
keyDecoder : JD.Decoder (Maybe Direction)
keyDecoder =
    JD.map2 Tuple.pair
        (JD.field "key" JD.string)
        (JD.field "repeat" JD.bool)
        |> JD.andThen
            (\( key, isRepeat ) ->
                if isRepeat then
                    JD.succeed Nothing
                else
                    JD.succeed (keyToDirection key)
            )


keyToDirection : String -> Maybe Direction
keyToDirection key =
    case key of
        "ArrowUp" -> Just Up
        "w" -> Just Up
        "W" -> Just Up
        "ArrowDown" -> Just Down
        "s" -> Just Down
        "S" -> Just Down
        "ArrowLeft" -> Just Left
        "a" -> Just Left
        "A" -> Just Left
        "ArrowRight" -> Just Right
        "d" -> Just Right
        "D" -> Just Right
        _ -> Nothing
```

2. Update Main.elm to use keyboard input and ports:
```elm
module Main exposing (main)

import Browser
import Browser.Events
import Html exposing (Html, div, text, h1)
import Html.Attributes exposing (class, style)
import Json.Decode as JD
import Json.Encode as JE

import Input
import Ports
import Snake exposing (Direction(..))
import Game exposing (GameState)


type alias Model =
    { gameState : Maybe GameState
    , playerId : Maybe String
    , currentDirection : Direction
    , connectionStatus : ConnectionStatus
    , error : Maybe String
    }


type ConnectionStatus
    = Disconnected
    | Connecting
    | Connected


type Msg
    = KeyPressed (Maybe Direction)
    | GotGameState JD.Value
    | GotError String
    | PlayerJoined JD.Value
    | PlayerLeft JD.Value
    | GotTick JD.Value
    | JoinGame


init : () -> ( Model, Cmd Msg )
init _ =
    ( { gameState = Nothing
      , playerId = Nothing
      , currentDirection = Right
      , connectionStatus = Disconnected
      , error = Nothing
      }
    , Cmd.none
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        JoinGame ->
            ( { model | connectionStatus = Connecting }
            , Ports.joinGame (JE.object [])
            )

        KeyPressed maybeDir ->
            case maybeDir of
                Just dir ->
                    let
                        _ = Debug.log "Direction change" (Snake.directionToString dir)
                    in
                    ( { model | currentDirection = dir }
                    , Ports.sendDirection
                        (JE.object [ ( "direction", JE.string (Snake.directionToString dir) ) ])
                    )

                Nothing ->
                    ( model, Cmd.none )

        GotGameState value ->
            case JD.decodeValue Game.decoder value of
                Ok state ->
                    ( { model
                      | gameState = Just state
                      , connectionStatus = Connected
                      }
                    , Cmd.none
                    )

                Err err ->
                    let
                        _ = Debug.log "Decode error" (JD.errorToString err)
                    in
                    ( model, Cmd.none )

        GotError errorMsg ->
            ( { model | error = Just errorMsg }, Cmd.none )

        PlayerJoined _ ->
            -- Will handle in Phase 3
            ( model, Cmd.none )

        PlayerLeft _ ->
            -- Will handle in Phase 3
            ( model, Cmd.none )

        GotTick value ->
            -- Will handle in Phase 3
            let
                _ = Debug.log "Tick received" value
            in
            ( model, Cmd.none )


view : Model -> Html Msg
view model =
    div [ class "game-container", style "padding" "20px" ]
        [ h1 [] [ text "Snaker - Elm 0.19.1" ]
        , div []
            [ text ("Status: " ++ connectionStatusToString model.connectionStatus) ]
        , div []
            [ text ("Direction: " ++ Snake.directionToString model.currentDirection) ]
        , case model.error of
            Just err ->
                div [ style "color" "red" ] [ text ("Error: " ++ err) ]
            Nothing ->
                text ""
        , case model.gameState of
            Just state ->
                div []
                    [ text ("Snakes: " ++ String.fromInt (List.length state.snakes))
                    , text (", Apples: " ++ String.fromInt (List.length state.apples))
                    ]
            Nothing ->
                div [] [ text "Waiting for game state..." ]
        ]


connectionStatusToString : ConnectionStatus -> String
connectionStatusToString status =
    case status of
        Disconnected -> "Disconnected"
        Connecting -> "Connecting..."
        Connected -> "Connected"


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.batch
        [ Browser.Events.onKeyDown (JD.map KeyPressed Input.keyDecoder)
        , Ports.receiveGameState GotGameState
        , Ports.receiveError GotError
        , Ports.playerJoined PlayerJoined
        , Ports.playerLeft PlayerLeft
        , Ports.receiveTick GotTick
        ]


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
```

3. Create js/app.ts with minimal Elm initialization (port wiring comes in Plan 03):
```typescript
// Elm application entry point
// @ts-ignore - Elm types will be generated by esbuild-plugin-elm
import { Elm } from "../src/Main.elm";

interface ElmApp {
  ports: {
    joinGame: { subscribe: (callback: (data: unknown) => void) => void };
    leaveGame: { subscribe: (callback: () => void) => void };
    sendDirection: { subscribe: (callback: (data: unknown) => void) => void };
    receiveGameState: { send: (data: unknown) => void };
    receiveError: { send: (message: string) => void };
    playerJoined: { send: (data: unknown) => void };
    playerLeft: { send: (data: unknown) => void };
    receiveTick: { send: (data: unknown) => void };
  };
}

// Initialize Elm application
const app: ElmApp = Elm.Main.init({
  node: document.getElementById("elm-app"),
});

// Temporary: log port activity for debugging
app.ports.joinGame.subscribe((data) => {
  console.log("Port: joinGame", data);
});

app.ports.sendDirection.subscribe((data) => {
  console.log("Port: sendDirection", data);
});

console.log("Elm app initialized with ports");
```

4. Verify complete build:
```bash
cd assets && node build.js
```
  </action>
  <verify>
    cd /Users/julian/code/elm/snaker-elm/assets && node build.js 2>&1
  </verify>
  <done>
    esbuild compiles successfully, output files created in priv/static/assets/
  </done>
</task>

</tasks>

<verification>
Full verification:
```bash
cd /Users/julian/code/elm/snaker-elm/assets

# Verify Elm compiles
elm make src/Main.elm --output=/dev/null

# Verify full build
node build.js

# Check output exists
ls -la ../priv/static/assets/app.js
```

Check all source files exist:
```bash
ls -la src/*.elm js/*.ts
```
</verification>

<success_criteria>
1. `elm make src/Main.elm` succeeds without errors
2. `node build.js` produces output in priv/static/assets/
3. elm.json contains elm-version 0.19.1
4. Main.elm uses Browser.element (not Html.program)
5. Input.elm uses Browser.Events.onKeyDown with repeat filtering
6. Ports.elm defines all required ports for game communication
7. app.ts initializes Elm and logs port activity
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend-migration/02-02-SUMMARY.md`
</output>
