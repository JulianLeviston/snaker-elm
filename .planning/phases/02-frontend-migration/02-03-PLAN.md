---
phase: 02-frontend-migration
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - assets/js/socket.ts
  - assets/js/app.ts
  - lib/snaker_web/templates/page/index.html.eex
autonomous: false

must_haves:
  truths:
    - "WebSocket connects to Phoenix server"
    - "Player successfully joins game:snake channel"
    - "Direction changes sent via port reach the server"
    - "Server tick events received by Elm app"
  artifacts:
    - path: "assets/js/socket.ts"
      provides: "Phoenix socket connection and channel logic"
      contains: "Socket"
    - path: "assets/js/app.ts"
      provides: "Elm initialization with socket wiring"
      contains: "connectSocket"
    - path: "lib/snaker_web/templates/page/index.html.eex"
      provides: "HTML page with Elm mount point"
      contains: 'id="elm-app"'
  key_links:
    - from: "assets/js/socket.ts"
      to: "assets/js/app.ts"
      via: "import and function call"
      pattern: "connectSocket\\(app\\)"
    - from: "assets/js/socket.ts"
      to: "lib/snaker_web/channels/game_channel.ex"
      via: 'channel.join("game:snake")'
      pattern: 'channel\\("game:snake"'
---

<objective>
Wire Phoenix Channels to Elm ports for real-time game communication.

Purpose: This completes the WebSocket integration, enabling bidirectional communication between the Elm frontend and Phoenix backend. Direction changes flow from Elm -> JS -> Phoenix Channel -> GameServer, and game state flows back via PubSub broadcasts.

Output: Working WebSocket connection where keyboard input reaches the server and tick events reach the Elm app.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-frontend-migration/02-RESEARCH.md
@.planning/phases/02-frontend-migration/02-CONTEXT.md
@.planning/phases/02-frontend-migration/02-02-SUMMARY.md
@lib/snaker_web/channels/game_channel.ex
@lib/snaker_web/channels/user_socket.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Phoenix socket module with port wiring</name>
  <files>
    assets/js/socket.ts
  </files>
  <action>
Create socket.ts that:
1. Imports Phoenix Socket and Channel from phoenix package
2. Defines ElmApp interface matching port types
3. Creates connectSocket function that:
   - Connects to /socket endpoint
   - Sets up joinGame port subscription to join channel
   - Sets up sendDirection port subscription to push to channel
   - Wires channel events to Elm incoming ports:
     - "tick" -> receiveTick
     - "player:join" -> playerJoined
     - "player:leave" -> playerLeft
   - On join success, sends initial game state to receiveGameState
   - On join error, sends to receiveError

```typescript
// Phoenix socket connection with Elm port wiring
import { Socket, Channel } from "phoenix";

interface ElmApp {
  ports: {
    joinGame: { subscribe: (callback: (data: unknown) => void) => void };
    leaveGame: { subscribe: (callback: () => void) => void };
    sendDirection: { subscribe: (callback: (data: unknown) => void) => void };
    receiveGameState: { send: (data: unknown) => void };
    receiveError: { send: (message: string) => void };
    playerJoined: { send: (data: unknown) => void };
    playerLeft: { send: (data: unknown) => void };
    receiveTick: { send: (data: unknown) => void };
  };
}

export function connectSocket(app: ElmApp): void {
  const socket = new Socket("/socket", {});
  socket.connect();

  let channel: Channel | null = null;

  // Handle join game request from Elm
  app.ports.joinGame.subscribe((payload) => {
    console.log("Joining game channel...", payload);

    channel = socket.channel("game:snake", payload as object);

    // Wire server events to Elm ports
    channel.on("tick", (delta) => {
      console.log("Tick received:", delta);
      app.ports.receiveTick.send(delta);
    });

    channel.on("player:join", (data) => {
      console.log("Player joined:", data);
      app.ports.playerJoined.send(data);
    });

    channel.on("player:leave", (data) => {
      console.log("Player left:", data);
      app.ports.playerLeft.send(data);
    });

    // Join the channel
    channel
      .join()
      .receive("ok", (response) => {
        console.log("Joined game channel successfully:", response);
        // Send initial game state to Elm
        if (response.game_state) {
          app.ports.receiveGameState.send(response.game_state);
        }
      })
      .receive("error", (response) => {
        console.error("Failed to join game channel:", response);
        app.ports.receiveError.send(response.reason || "Failed to join game");
      })
      .receive("timeout", () => {
        console.error("Channel join timeout");
        app.ports.receiveError.send("Connection timeout");
      });
  });

  // Handle direction changes from Elm
  app.ports.sendDirection.subscribe((data) => {
    if (channel) {
      console.log("Sending direction:", data);
      channel.push("player:change_direction", data as object);
    } else {
      console.warn("Cannot send direction: not connected to channel");
    }
  });

  // Handle leave game request from Elm
  app.ports.leaveGame.subscribe(() => {
    if (channel) {
      console.log("Leaving game channel...");
      channel.leave();
      channel = null;
    }
  });

  // Handle socket errors
  socket.onError(() => {
    console.error("Socket error");
    app.ports.receiveError.send("Socket connection error");
  });

  socket.onClose(() => {
    console.log("Socket closed");
  });
}
```
  </action>
  <verify>
    cd /Users/julian/code/elm/snaker-elm/assets && npx tsc --noEmit js/socket.ts 2>&1
  </verify>
  <done>
    TypeScript compiles socket.ts without type errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update app.ts and HTML template</name>
  <files>
    assets/js/app.ts
    lib/snaker_web/templates/page/index.html.eex
  </files>
  <action>
1. Update app.ts to import and use socket module, and auto-join on load:
```typescript
// Elm application entry point with Phoenix socket integration
// @ts-ignore - Elm types will be generated by esbuild-plugin-elm
import { Elm } from "../src/Main.elm";
import { connectSocket } from "./socket";

interface ElmApp {
  ports: {
    joinGame: { subscribe: (callback: (data: unknown) => void) => void };
    leaveGame: { subscribe: (callback: () => void) => void };
    sendDirection: { subscribe: (callback: (data: unknown) => void) => void };
    receiveGameState: { send: (data: unknown) => void };
    receiveError: { send: (message: string) => void };
    playerJoined: { send: (data: unknown) => void };
    playerLeft: { send: (data: unknown) => void };
    receiveTick: { send: (data: unknown) => void };
  };
}

// Wait for DOM to be ready
document.addEventListener("DOMContentLoaded", () => {
  const elmNode = document.getElementById("elm-app");

  if (!elmNode) {
    console.error("Could not find #elm-app element");
    return;
  }

  // Initialize Elm application
  const app: ElmApp = Elm.Main.init({
    node: elmNode,
  });

  console.log("Elm app initialized");

  // Connect Phoenix socket and wire to Elm ports
  connectSocket(app);

  // Auto-join game on load (send empty payload to trigger join)
  setTimeout(() => {
    app.ports.receiveGameState.send = app.ports.receiveGameState.send; // Ensure port exists
    // Trigger joinGame from Elm side via init or we can push directly
    // For now, let's trigger from JS side
    console.log("Triggering game join...");
  }, 100);
});
```

2. Update Main.elm to auto-join on init:
```elm
-- In init function, replace Cmd.none with:
init : () -> ( Model, Cmd Msg )
init _ =
    ( { gameState = Nothing
      , playerId = Nothing
      , currentDirection = Right
      , connectionStatus = Connecting
      , error = Nothing
      }
    , Ports.joinGame (JE.object [])
    )
```

3. Update the HTML template to mount Elm app. Find or create the page template:
```html
<div id="elm-app"></div>
<script src="<%= static_path(@conn, "/assets/app.js") %>"></script>
```

Note: Check if the template uses Routes.static_path or static_path helper.
  </action>
  <verify>
    cd /Users/julian/code/elm/snaker-elm/assets && node build.js 2>&1 && ls -la ../priv/static/assets/app.js
  </verify>
  <done>
    Build succeeds, app.js output exists with socket integration
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete WebSocket integration:
    - Phoenix socket connection via socket.ts
    - Elm ports wired to channel events
    - Auto-join game on page load
    - Direction changes sent to server
    - Tick events received from server
  </what-built>
  <how-to-verify>
    1. Start Phoenix server: `mix phx.server`
    2. Open browser to http://localhost:4000
    3. Open browser DevTools Console (F12)
    4. Verify you see:
       - "Elm app initialized"
       - "Joining game channel..."
       - "Joined game channel successfully:" with game state
       - "Tick received:" messages every 100ms
    5. Press arrow keys or WASD
    6. Verify you see "Sending direction:" messages in console
    7. (Optional) Open second browser tab, verify both see player events
  </how-to-verify>
  <resume-signal>Type "approved" if WebSocket communication works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Full integration test:
```bash
# Terminal 1: Start Phoenix
cd /Users/julian/code/elm/snaker-elm && mix phx.server

# Terminal 2: Check build output
ls -la priv/static/assets/app.js
```

Browser verification:
1. Open http://localhost:4000
2. Check console for connection messages
3. Press arrow keys to test input
4. Watch for tick events
</verification>

<success_criteria>
1. Phoenix socket connects without errors
2. Channel join succeeds with game state response
3. Tick events flow from server to Elm (visible in console)
4. Direction changes flow from Elm to server (visible in console)
5. Browser console shows bidirectional communication working
</success_criteria>

<output>
After completion, create `.planning/phases/02-frontend-migration/02-03-SUMMARY.md`
</output>
