---
phase: 07-migration-polish
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - assets/js/peerjs-ports.ts
  - assets/src/Network/Protocol.elm
  - assets/src/Network/HostGame.elm
  - assets/src/Network/ClientGame.elm
  - assets/src/Main.elm
  - assets/src/View/Board.elm
  - assets/css/app.css

autonomous: false

must_haves:
  truths:
    - "When host disconnects, game continues with new host"
    - "New host is deterministically elected (lowest peer ID)"
    - "Migration is seamless - no notification, game barely hiccups"
    - "Disconnected player's snake continues straight with visual fade"
    - "Reconnecting player resumes their snake if still alive"
    - "Small crown icon shows by host's snake"
    - "Connection lost screen appears when migration fails completely"
  artifacts:
    - path: "assets/js/peerjs-ports.ts"
      provides: "Host migration detection and mesh topology for migration"
      contains: "electNewHost"
    - path: "assets/src/Network/Protocol.elm"
      provides: "HostMigrated message type"
      contains: "HostMigrated"
    - path: "assets/src/View/Board.elm"
      provides: "Host indicator and orphaned snake opacity"
      contains: "host-indicator"
  key_links:
    - from: "assets/js/peerjs-ports.ts"
      to: "assets/src/Main.elm"
      via: "hostMigration port"
      pattern: "ports.hostMigration.send"
    - from: "assets/src/Main.elm"
      to: "assets/src/Network/HostGame.elm"
      via: "transition to host"
      pattern: "HostGame.init.*lastKnownGameState"
---

<objective>
Implement seamless host migration when the current host disconnects, plus reconnection support for temporarily disconnected players. When the host leaves, the client with the lowest peer ID automatically becomes the new host and continues the game loop. Disconnected players' snakes continue moving straight with visual fade until they collide, and can be reclaimed on reconnection.

Purpose: Make P2P multiplayer robust against network issues and player disconnections. Players expect the game to continue even if the host leaves.

Output: Host migration election logic, orphaned snake handling, reconnection support, host indicator UI, connection lost screen.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-migration-polish/07-CONTEXT.md
@.planning/phases/07-migration-polish/07-RESEARCH.md
@.planning/phases/06-host-client-integration/06-01-SUMMARY.md
@.planning/phases/06-host-client-integration/06-02-SUMMARY.md

@assets/src/Main.elm
@assets/js/peerjs-ports.ts
@assets/src/Network/Protocol.elm
@assets/src/Network/HostGame.elm
@assets/src/Network/ClientGame.elm
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement host migration in peerjs-ports.ts</name>
  <files>assets/js/peerjs-ports.ts, assets/src/Ports.elm</files>
  <action>
    1. Add peer list tracking in peerjs-ports.ts:
       ```typescript
       let myPeerId: string | null = null;
       let isHost: boolean = false;
       let knownPeers: Set<string> = new Set(); // Track all peers in room
       ```

    2. Add election function:
       ```typescript
       function electNewHost(excludeId: string): string | null {
         const candidates = Array.from(knownPeers)
           .filter(id => id !== excludeId)
           .sort(); // Lexicographic sort = lowest ID first
         return candidates[0] || null;
       }
       ```

    3. Modify host connection handling to track peers:
       - On host, when client connects: `knownPeers.add(conn.peer)`
       - On client, track all peers from state sync messages

    4. Modify disconnect handling for clients:
       - When host disconnects (client side):
         ```typescript
         const newHostId = electNewHost(oldHostId);
         if (newHostId === myPeerId) {
           // I am the new host - notify Elm to transition
           app.ports.hostMigration.send({
             type: 'become_host',
             myPeerId: myPeerId,
             peers: Array.from(knownPeers)
           });
           isHost = true;
           // Set up to receive connections from other clients
           setupHostConnectionHandlers();
         } else if (newHostId) {
           // Someone else is new host - connect to them
           app.ports.hostMigration.send({
             type: 'new_host',
             newHostId: newHostId
           });
           // Note: In star topology, we lose connection when host dies
           // Actual reconnection to new host requires mesh or manual reconnect
         } else {
           // No peers left, game over
           app.ports.hostMigration.send({ type: 'connection_lost' });
         }
         ```

    5. Add new port interface:
       ```typescript
       hostMigration: { send: (data: { type: string, myPeerId?: string, newHostId?: string, peers?: string[] }) => void };
       ```

    6. In Ports.elm, add:
       ```elm
       port hostMigration : (JD.Value -> msg) -> Sub msg
       ```

    **Important limitation for star topology:**
    In pure star topology (current implementation), clients only connect to host.
    When host disconnects, clients lose their only connection and cannot communicate
    with each other to elect a new host. For true migration:

    Option A: Each client reconnects to new host after election (requires signaling server)
    Option B: Implement mesh topology where clients also connect to each other

    For this phase: Implement Option A - election happens client-side, client reconnects
    to elected new host via PeerJS signaling. The new host's peer ID is already known.
  </action>
  <verify>
    - TypeScript compiles: `npm run build` in assets/
    - Port interface types are correct
    - Console logs show peer list updates when clients join/leave
  </verify>
  <done>
    - Peer list tracking implemented
    - electNewHost function returns lowest ID
    - Disconnect triggers election logic
    - hostMigration port notifies Elm of migration events
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle migration in Main.elm with orphaned snakes</name>
  <files>assets/src/Main.elm, assets/src/Network/Protocol.elm, assets/src/Network/HostGame.elm, assets/src/Network/ClientGame.elm</files>
  <action>
    1. Add Protocol.elm message types:
       ```elm
       type GameMessage
           = StateSync StateSyncPayload
           | Input InputPayload
           | PlayerJoin PlayerJoinPayload
           | PlayerLeave String
           | HostMigrated { newHostId : String, tick : Int }
       ```

    2. Add SnakeState to track orphaned snakes in HostGame.elm:
       ```elm
       type SnakeState = Active | Orphaned | Dead

       type alias SnakeData =
           { body : List Position
           , direction : Direction
           , state : SnakeState  -- Add this field
           , ...
           }
       ```

    3. Update HostGame.tick to handle orphaned snakes:
       - Orphaned snakes continue moving in last direction
       - Orphaned snakes can collide and die (become Dead)
       - No input processing for orphaned snakes

    4. Add migration messages to Main.elm:
       ```elm
       | GotHostMigration JD.Value
       ```

    5. Handle GotHostMigration:
       ```elm
       GotHostMigration value ->
           case decodeHostMigration value of
               BecomeHost { myPeerId, peers } ->
                   -- Transition from client to host
                   -- Initialize HostGame with current ClientGame state
                   let
                       hostState = HostGame.fromClientState model.clientGame myPeerId
                   in
                   ( { model
                     | hostGame = Just hostState
                     , clientGame = Nothing
                     , p2pState = P2PConnected Host myPeerId
                     }
                   , Cmd.none
                   )

               NewHost { newHostId } ->
                   -- Wait for new host to start broadcasting
                   -- Connection will be re-established automatically
                   ( { model | expectedHostId = Just newHostId }, Cmd.none )

               ConnectionLost ->
                   -- Show connection lost screen
                   ( { model | screen = ConnectionLostScreen }, Cmd.none )
       ```

    6. Add HostGame.fromClientState function:
       ```elm
       fromClientState : ClientGameState -> String -> HostGameState
       -- Converts client's view of game into host state
       ```

    7. Add ConnectionLostScreen to Screen type and view:
       - Message: "Connection lost"
       - Buttons: "Create New Room", "Go Home"

    8. Mark disconnected player snakes as Orphaned:
       - In HostGame.removePlayer, set snake state to Orphaned instead of immediate removal
       - Snake continues until collision (natural death)
  </action>
  <verify>
    - Elm compiles: `cd assets && npx elm make src/Main.elm --output=/dev/null`
    - HostGame.tick handles Active and Orphaned snakes differently
    - ConnectionLostScreen renders with expected buttons
  </verify>
  <done>
    - Protocol.elm has HostMigrated message type
    - SnakeState tracks Active/Orphaned/Dead
    - Orphaned snakes continue straight and can die
    - Client transitions to host on become_host migration
    - ConnectionLostScreen shows when no peers remain
  </done>
</task>

<task type="auto">
  <name>Task 3: Add host indicator and orphaned snake visual styling</name>
  <files>assets/src/View/Board.elm, assets/css/app.css</files>
  <action>
    1. Update Board.elm to show host indicator:
       - Pass hostId to snake rendering
       - For host's snake, render small crown icon near head
       - Crown SVG path: `M 0 8 L 4 0 L 8 8 L 6.5 5 L 4 7 L 1.5 5 Z`
       - Position: offset from snake head (x+10, y-10)
       - Color: gold (#FFD700) with thin black stroke

    2. Update Board.elm snake rendering for orphaned state:
       - Pass snake state to view function
       - Add opacity styling based on state:
         ```elm
         let
             opacity =
                 case snake.state of
                     Orphaned -> "0.5"
                     _ -> "1.0"
         in
         Svg.g [ Svg.Attributes.opacity opacity ] [ ... ]
         ```

    3. Add CSS for host indicator:
       ```css
       .host-indicator {
         fill: #FFD700;
         stroke: #000000;
         stroke-width: 0.5;
       }
       .snake.orphaned {
         opacity: 0.5;
       }
       ```

    4. Update snake class generation in Board.elm:
       - Add "orphaned" class when snake.state == Orphaned

    5. Test visual appearance:
       - Host snake has small gold crown by head
       - Disconnected player's snake appears faded (50% opacity)
  </action>
  <verify>
    - `npm run build` compiles
    - Host snake shows crown icon
    - Disconnecting a client (close tab) shows their snake fading
    - Faded snake continues moving and can die
  </verify>
  <done>
    - Crown icon renders next to host's snake head
    - Orphaned snakes render at 50% opacity
    - CSS styling supports both indicators
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Host migration, reconnection, and visual indicators</what-built>
  <how-to-verify>
    **Setup:** Open 3 browser windows (incognito helps)

    **Test 1: Host Migration**
    1. Window 1: Create room (becomes host, note crown icon on snake)
    2. Window 2: Join room
    3. Window 3: Join room
    4. Close Window 1 (host disconnects)
    5. Expected: Game continues in Windows 2 and 3, one becomes new host (crown moves)

    **Test 2: Orphaned Snake**
    1. Create room, have 2 players join
    2. Close one client window (not host)
    3. Expected: Their snake fades to 50% opacity, continues straight
    4. Expected: Snake dies when it hits wall or itself

    **Test 3: Connection Lost**
    1. Two players only (host + 1 client)
    2. Host closes window
    3. Expected: Client shows "Connection lost" screen with "Create New Room" button

    **Test 4: Visual Indicators**
    1. Create room, verify crown icon on host's snake
    2. Crown is small, subtle, near snake head
    3. Not distracting during gameplay
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Full migration test:
1. Host + 2 clients playing
2. Host disconnects
3. Client with lowest peer ID becomes new host (automatically)
4. Game continues with minimal disruption
5. Old host's snake fades and continues until death

Edge cases:
- Last player: shows "Connection lost" screen
- Host crashes during state broadcast: new host uses last known state
- Network partition: detected via PeerJS disconnection
</verification>

<success_criteria>
- [ ] Host disconnection triggers election (lowest peer ID wins)
- [ ] New host continues game loop from current state
- [ ] Migration is seamless - no notification popup
- [ ] Disconnected player's snake fades to 50% opacity
- [ ] Orphaned snake continues straight until collision death
- [ ] Crown icon shows by host's snake head
- [ ] "Connection lost" screen when no peers remain
- [ ] All transitions work without page refresh
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration-polish/07-03-SUMMARY.md`
</output>
