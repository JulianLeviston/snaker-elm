---
phase: 04-game-engine-port
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - assets/src/Engine/Apple.elm
  - assets/src/LocalGame.elm
  - assets/src/Main.elm
autonomous: true

must_haves:
  truths:
    - "Eating apple grows snake by 3 segments"
    - "Eating apple increments score by 1"
    - "New apple spawns when one is eaten"
    - "Apple expires and respawns after timeout if not eaten"
    - "Minimum 3 apples always present on board"
  artifacts:
    - path: "assets/src/Engine/Apple.elm"
      provides: "Apple spawning and eating logic"
      exports: ["spawnIfNeeded", "checkEaten", "growthAmount", "ticksUntilExpiry"]
    - path: "assets/src/LocalGame.elm"
      provides: "Complete game logic with apple handling"
      contains: "checkAppleEating"
    - path: "assets/src/Main.elm"
      provides: "Coordinated random apple spawning"
      contains: "NewApplePosition"
  key_links:
    - from: "assets/src/LocalGame.elm"
      to: "Engine/Apple.elm"
      via: "checkAppleEating function"
      pattern: "Apple\\.checkEaten"
    - from: "assets/src/Main.elm"
      to: "LocalGame.elm"
      via: "tick triggers apple spawn command"
      pattern: "Random\\.generate.*NewApplePosition"
---

<objective>
Implement the apple system: spawning, eating, growth, score tracking, and expiration.

Purpose: Complete the game engine by adding the core gameplay loop - eating apples to grow and score points. This plan delivers all apple-related requirements (ENG-03 through ENG-06).
Output: Fully playable single-player snake with apple eating, growth, scoring, and apple expiration.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-game-engine-port/04-CONTEXT.md
@.planning/phases/04-game-engine-port/04-RESEARCH.md
@.planning/phases/04-game-engine-port/04-01-SUMMARY.md

Reference files:
@assets/src/LocalGame.elm (from Plan 01)
@assets/src/Main.elm (from Plan 01)
@lib/snaker/game/apple.ex (Elixir reference - spawning, eating)
@lib/snaker/game_server.ex (Elixir reference - tick order)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Engine/Apple module with spawning and expiration</name>
  <files>
    assets/src/Engine/Apple.elm
  </files>
  <action>
Create `assets/src/Engine/Apple.elm`:

```elm
module Engine.Apple exposing
    ( Apple
    , checkEaten
    , spawnIfNeeded
    , tickExpiredApples
    , growthAmount
    , minApples
    , ticksUntilExpiry
    , randomSafePosition
    )
```

**Types:**
```elm
type alias Apple =
    { position : Position
    , expiresAtTick : Int  -- Tick when apple expires and respawns
    }
```

**Constants (match Elixir + add expiry):**
- `minApples : Int` = 3
- `growthAmount : Int` = 3 (segments per apple)
- `ticksUntilExpiry : Int` = 100 (10 seconds at 100ms/tick - reasonable timeout)

**Functions:**

`checkEaten : Position -> List Apple -> { eaten : Bool, remaining : List Apple, eatenApple : Maybe Apple }`
- Check if snake head position matches any apple position
- Return whether eaten, remaining apples, and the eaten apple (for potential respawn trigger)

`spawnIfNeeded : List Apple -> Int -> Random.Generator (List Apple)`
- If length apples < minApples, generate position and add apple with expiry
- Takes currentTick to set expiresAtTick = currentTick + ticksUntilExpiry
- Returns generator that produces updated apple list

`tickExpiredApples : Int -> List Apple -> { expired : List Apple, remaining : List Apple }`
- Check each apple's expiresAtTick against currentTick
- Return expired apples (need respawning) and remaining apples

`randomSafePosition : List Position -> { width : Int, height : Int } -> Random.Generator Position`
- Generate random position not in occupied list
- Use Random.int for x and y, filter against occupied
- Per research: use retry approach with Random.andThen for safe spawn

**Note on Random.generate:**
This module returns Random.Generator values. The caller (Main.elm) uses Random.generate to turn them into Cmd Msg. This keeps the module pure and testable.
  </action>
  <verify>
Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Engine/Apple.elm --output=/dev/null` - compiles without errors.
  </verify>
  <done>
Engine/Apple.elm exports Apple type, checkEaten, spawnIfNeeded, tickExpiredApples, and randomSafePosition. All functions are pure (generators for random operations).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire apple system into LocalGame and Main</name>
  <files>
    assets/src/LocalGame.elm
    assets/src/Main.elm
    assets/src/Game.elm
  </files>
  <action>
**Update assets/src/LocalGame.elm:**

Change apples type:
- `apples : List Apple` (using Engine.Apple.Apple type)

Add/update functions:

`tick : LocalGameState -> { state : LocalGameState, needsAppleSpawn : Bool, expiredApples : List Apple }`
- Order: applyInput -> move -> collisions -> checkAppleEating -> tickExpiredApples
- Return updated state plus signals for Main to handle random spawning
- If apple eaten: increment score, grow snake (pendingGrowth += Apple.growthAmount)
- If apples expired: return them so Main can spawn replacements

`checkAppleEating : LocalGameState -> LocalGameState`
- Get snake head position
- Call Apple.checkEaten
- If eaten: update score, grow snake, update apples list

`addApple : Apple -> LocalGameState -> LocalGameState`
- Called when Main receives random position
- Add apple to list

`needsMoreApples : LocalGameState -> Bool`
- Check if length apples < Apple.minApples

`getOccupiedPositions : LocalGameState -> List Position`
- Return all snake segments + apple positions
- Used by Main for safe spawn generation

**Update assets/src/Main.elm:**

Add Msg variants:
- `NewApplePosition Position`
- `SpawnInitialApples`

Update Model:
- `pendingAppleSpawns : Int` (track in-flight Random.generate calls to avoid over-spawning)

Update init:
- After InitGame, trigger initial apple spawning (3 apples)

Update update function:
- `Tick _`:
  - Call LocalGame.tick
  - If needsAppleSpawn or expiredApples: issue Random.generate commands
  - Track pendingAppleSpawns to avoid race conditions (per research pitfall #4)
- `NewApplePosition pos`:
  - Decrement pendingAppleSpawns
  - Create Apple with expiresAtTick = currentTick + ticksUntilExpiry
  - Call LocalGame.addApple
- `SpawnInitialApples`:
  - Spawn minApples (3) to start game

Update view:
- Map LocalGameState.apples to Game.Apple format for Board.view
- Display score (add to UI - simple text display)

**Update assets/src/Game.elm (if needed):**
- Ensure Apple type is compatible or create adapter function
- Board.view expects `List { position : Position }` which matches

**Score display:**
Add simple score display in Main.view:
```elm
div [ class "score" ] [ text ("Score: " ++ String.fromInt localGame.score) ]
```
  </action>
  <verify>
1. `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Main.elm --output=/dev/null` - compiles
2. Start server: `cd /Users/julian/code/elm/snaker-elm && mix phx.server`
3. Open browser - should see 3 apples on board
4. Guide snake to apple - snake grows by 3 segments
5. Score increments when eating apple
6. New apple spawns when one is eaten
7. Wait 10 seconds without eating an apple - it should move (expire and respawn)
  </verify>
  <done>
Apple eating grows snake by 3 segments. Score increments on eat. Minimum 3 apples maintained. Apples expire after timeout and respawn. All ENG requirements (01-07) satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Main.elm --output=/dev/null` compiles
2. Open http://localhost:4000:
   - 3 apples visible on board at start
   - Snake moves continuously (from Plan 01)
   - Eating apple: snake grows by 3, score +1, new apple spawns
   - Wait 10s: untouched apple respawns at new location
3. Full gameplay loop: move -> eat -> grow -> score -> repeat
</verification>

<success_criteria>
- [ ] ENG-03: Snake grows when eating apple (3 segments)
- [ ] ENG-04: Apple spawns at random position when eaten
- [ ] ENG-05: Apple expires after timeout (10s) and respawns
- [ ] ENG-06: Score increments when apple eaten
- [ ] Minimum 3 apples always on board
- [ ] No race conditions in apple spawning (pendingAppleSpawns tracking)
- [ ] Score displayed in UI
- [ ] All Elm files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-game-engine-port/04-02-SUMMARY.md`
</output>
