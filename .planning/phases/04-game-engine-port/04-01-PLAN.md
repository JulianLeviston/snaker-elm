---
phase: 04-game-engine-port
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - assets/src/Engine/Grid.elm
  - assets/src/Engine/Collision.elm
  - assets/src/LocalGame.elm
  - assets/src/Main.elm
  - assets/src/Snake.elm
autonomous: true

must_haves:
  truths:
    - "Snake moves continuously in current direction each tick"
    - "Snake wraps around when crossing board edges"
    - "Arrow keys change snake direction (with opposite-direction prevention)"
    - "Snake dies when colliding with itself"
  artifacts:
    - path: "assets/src/Engine/Grid.elm"
      provides: "Edge wrapping and safe position utilities"
      exports: ["wrapPosition", "nextPosition"]
    - path: "assets/src/Engine/Collision.elm"
      provides: "Collision detection"
      exports: ["collidesWithSelf", "collidesWithOther"]
    - path: "assets/src/LocalGame.elm"
      provides: "Local game state and tick logic"
      exports: ["LocalGameState", "tick", "init"]
    - path: "assets/src/Main.elm"
      provides: "Game loop with Time.every subscription"
      contains: "Time.every 100"
  key_links:
    - from: "assets/src/Main.elm"
      to: "LocalGame.tick"
      via: "Tick msg in update function"
      pattern: "Tick.*->.*LocalGame\\.tick"
    - from: "assets/src/LocalGame.elm"
      to: "Engine/Grid.elm"
      via: "wrapPosition in moveSnake"
      pattern: "Grid\\.wrapPosition"
    - from: "assets/src/LocalGame.elm"
      to: "Engine/Collision.elm"
      via: "collision check in tick"
      pattern: "Collision\\.collidesWithSelf"
---

<objective>
Implement the core game engine: tick loop, snake movement with edge wrapping, input buffering, and collision detection.

Purpose: Create the foundation for standalone snake gameplay without server dependency. This plan delivers continuous snake movement and death on self-collision.
Output: Working snake that moves every 100ms, wraps at edges, responds to arrow keys, and dies on self-collision.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-game-engine-port/04-CONTEXT.md
@.planning/phases/04-game-engine-port/04-RESEARCH.md

Reference files:
@assets/src/Main.elm (current Phoenix-connected version)
@assets/src/Snake.elm (existing types)
@assets/src/Game.elm (existing types)
@assets/src/Input.elm (keyboard handling - reuse)
@lib/snaker/game_server.ex (Elixir reference - tick order)
@lib/snaker/game/snake.ex (Elixir reference - movement, collision)
@lib/snaker/game/grid.ex (Elixir reference - wrapping, spawn)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Engine modules (Grid, Collision)</name>
  <files>
    assets/src/Engine/Grid.elm
    assets/src/Engine/Collision.elm
    assets/src/Snake.elm
  </files>
  <action>
Create `assets/src/Engine/` directory with two modules:

**Engine/Grid.elm:**
- `wrapPosition : Position -> { width : Int, height : Int } -> Position`
  - Use `rem (x + width) width` pattern to handle negative wrapping correctly
- `nextPosition : Position -> Direction -> Position`
  - Up: y - 1, Down: y + 1, Left: x - 1, Right: x + 1
- `defaultDimensions : { width : Int, height : Int }` = { width = 30, height = 40 }

**Engine/Collision.elm:**
- `collidesWithSelf : List Position -> Bool`
  - Check if head is in tail (first element vs rest)
- `collidesWithOther : Position -> List Position -> Bool`
  - Check if position is in any of the other positions
  - For future multi-snake support per CONTEXT decisions

**Snake.elm updates:**
- Add `pendingGrowth : Int` field to Snake type
- Add `isOppositeDirection : Direction -> Direction -> Bool` helper
- Add `validDirectionChange : Direction -> Direction -> Bool` (not opposite)

Match Elixir behavior from game/snake.ex and game/grid.ex.
  </action>
  <verify>
Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Engine/Grid.elm --output=/dev/null && npx elm make src/Engine/Collision.elm --output=/dev/null` - compiles without errors.
  </verify>
  <done>
Engine/Grid.elm exports wrapPosition and nextPosition. Engine/Collision.elm exports collidesWithSelf. Snake.elm has pendingGrowth field and direction validation helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LocalGame module and wire tick loop into Main</name>
  <files>
    assets/src/LocalGame.elm
    assets/src/Main.elm
  </files>
  <action>
**Create assets/src/LocalGame.elm:**

```elm
module LocalGame exposing (LocalGameState, init, tick, changeDirection, ...)
```

LocalGameState type:
- `snake : Snake` (single snake for single-player)
- `apples : List Position` (empty for now - Plan 02 adds apple logic)
- `grid : { width : Int, height : Int }`
- `inputBuffer : Maybe Direction` (first direction change per tick)
- `score : Int`
- `currentTick : Int`

Functions:
- `init : Random.Generator LocalGameState`
  - Random initial snake position, default grid, empty apples, score 0
- `tick : LocalGameState -> LocalGameState`
  - Order per Elixir game_server.ex: applyInput -> move -> collisions -> (eating in Plan 02)
  - If collision: respawn snake at random position (will need Cmd for random)
- `changeDirection : Direction -> LocalGameState -> LocalGameState`
  - Validate direction change (not opposite)
  - Only accept if inputBuffer is Nothing (rate limit)
- `moveSnake : LocalGameState -> LocalGameState`
  - Calculate new head using Grid.nextPosition
  - Wrap using Grid.wrapPosition
  - If pendingGrowth > 0: prepend head, keep all segments, decrement pendingGrowth
  - Else: prepend head, drop last segment
- `respawnSnake : Position -> LocalGameState -> LocalGameState`
  - Reset snake to single segment at position, direction right, pendingGrowth 0
  - Set invincibility (invincibleUntilTick = currentTick + 15 for 1500ms)

**Modify assets/src/Main.elm:**

Add new Msg variants:
- `Tick Time.Posix`
- `InitGame LocalGameState`
- `NewSpawnPosition Position` (for random respawn)

Add to Model:
- `localGame : Maybe LocalGameState`

Update subscriptions:
- Add `Time.every 100 Tick` for game loop
- Keep existing keyboard subscription

Update init:
- Generate initial game state using Random.generate InitGame LocalGame.init

Update update function:
- `Tick _` -> If localGame exists, call LocalGame.tick, handle respawn if collision detected
- `KeyPressed (Just dir)` -> If localGame exists, call LocalGame.changeDirection
- `InitGame state` -> Set localGame
- `NewSpawnPosition pos` -> Respawn snake at position

Update view:
- Render from localGame state instead of gameState when in local mode
- Reuse existing Board.view by mapping LocalGameState to GameState format

Keep existing Phoenix code paths for now (will be mode-selected in Phase 7).
  </action>
  <verify>
1. Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Main.elm --output=/dev/null` - compiles
2. Run `cd /Users/julian/code/elm/snaker-elm && mix phx.server`, open browser
3. Snake should move continuously to the right
4. Arrow keys should change direction (cannot reverse)
5. Snake should wrap when crossing edges
6. Snake should die and respawn when hitting itself (grow snake first by manually editing state, or wait for Plan 02)
  </verify>
  <done>
Snake moves every 100ms, wraps at edges, responds to arrow keys with direction validation, and respawns on self-collision. LocalGame module provides pure game logic functions.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Main.elm --output=/dev/null` compiles
2. Open http://localhost:4000 - snake moves continuously
3. Press arrow keys - snake changes direction (except reverse)
4. Snake crossing edge appears on opposite side
5. (Self-collision testable after Plan 02 adds growth, or by manually growing snake)
</verification>

<success_criteria>
- [ ] ENG-01: Game tick loop runs at 100ms intervals (Time.every 100 Tick)
- [ ] ENG-02: Snake movement follows current direction each tick
- [ ] ENG-07: Snake wraps around board edges
- [ ] Input buffer prevents direction reversal
- [ ] Self-collision detection causes respawn
- [ ] All Elm files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-game-engine-port/04-01-SUMMARY.md`
</output>
