---
phase: 01-backend-modernization
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - lib/snaker/game_server.ex
  - lib/snaker/game/snake.ex
  - lib/snaker/game/apple.ex
  - lib/snaker/game/grid.ex
  - lib/snaker/application.ex
  - lib/snaker_web/channels/game_channel.ex
  - lib/snaker_web/channels/user_socket.ex
autonomous: true

must_haves:
  truths:
    - "Server maintains authoritative game state (snakes, apples)"
    - "Server ticks every 100ms and logs tick events"
    - "Player join creates snake in game state"
    - "Player disconnect removes snake from game state"
    - "Direction changes are validated (no 180-degree reversals)"
  artifacts:
    - path: "lib/snaker/game_server.ex"
      provides: "GenServer with tick loop, authoritative state"
      contains: "defmodule Snaker.GameServer"
      min_lines: 100
    - path: "lib/snaker/game/snake.ex"
      provides: "Snake movement and collision logic"
      contains: "defmodule Snaker.Game.Snake"
    - path: "lib/snaker/game/apple.ex"
      provides: "Apple spawning logic"
      contains: "defmodule Snaker.Game.Apple"
    - path: "lib/snaker/game/grid.ex"
      provides: "Grid boundaries and safe spawn positions"
      contains: "defmodule Snaker.Game.Grid"
  key_links:
    - from: "lib/snaker/application.ex"
      to: "lib/snaker/game_server.ex"
      via: "GameServer in supervision tree"
      pattern: "Snaker\\.GameServer"
    - from: "lib/snaker_web/channels/game_channel.ex"
      to: "lib/snaker/game_server.ex"
      via: "Channel calls GameServer functions"
      pattern: "GameServer\\."
    - from: "lib/snaker/game_server.ex"
      to: "lib/snaker/game/snake.ex"
      via: "GameServer uses Snake module"
      pattern: "Snake\\."
---

<objective>
Implement server-authoritative game state with GameServer GenServer and game logic modules.

Purpose: Move all game logic (snake movement, collision detection, apple spawning) to server. This is the core architectural change that fixes the multiplayer sync bug - server becomes the single source of truth.
Output: GameServer with 100ms tick loop, snake/apple/grid logic modules, updated channel integration.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/01-backend-modernization/01-RESEARCH.md
@.planning/phases/01-backend-modernization/01-CONTEXT.md
@.planning/phases/01-backend-modernization/01-02-SUMMARY.md
@lib/snaker/worker.ex
@lib/snaker/application.ex
@lib/snaker_web/channels/game_channel.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game logic modules</name>
  <files>lib/snaker/game/snake.ex, lib/snaker/game/apple.ex, lib/snaker/game/grid.ex</files>
  <action>
Create pure game logic modules in `lib/snaker/game/` directory.

**lib/snaker/game/grid.ex:**
```elixir
defmodule Snaker.Game.Grid do
  @moduledoc "Grid boundaries and position utilities"

  @default_width 30
  @default_height 40

  def default_dimensions, do: {@default_width, @default_height}

  def in_bounds?({x, y}, {width, height}) do
    x >= 0 and x < width and y >= 0 and y < height
  end

  def find_safe_spawn(occupied, dimensions) do
    {width, height} = dimensions
    all_positions = for x <- 0..(width-1), y <- 0..(height-1), do: {x, y}
    available = all_positions -- MapSet.to_list(occupied)

    case available do
      [] -> nil  # Grid full (shouldn't happen in practice)
      positions -> Enum.random(positions)
    end
  end

  def random_position({width, height}) do
    {:rand.uniform(width) - 1, :rand.uniform(height) - 1}
  end
end
```

**lib/snaker/game/snake.ex:**
```elixir
defmodule Snaker.Game.Snake do
  @moduledoc "Snake movement, growth, and collision detection"

  alias Snaker.Game.Grid

  @directions %{
    up: {0, -1},
    down: {0, 1},
    left: {-1, 0},
    right: {1, 0}
  }

  @opposites %{up: :down, down: :up, left: :right, right: :left}

  def new(id, position, color, name) do
    %{
      id: id,
      segments: [position],  # Head-first list
      direction: :right,
      color: color,
      name: name,
      pending_growth: 0,
      invincible_until: System.monotonic_time(:millisecond) + 1500
    }
  end

  def move(snake, grid_dimensions) do
    {dx, dy} = @directions[snake.direction]
    [{hx, hy} | _] = snake.segments
    new_head = {hx + dx, hy + dy}

    # Handle wall wrap-around (or collision - depending on game rules)
    # For now, wrap around
    {width, height} = grid_dimensions
    new_head = {rem(elem(new_head, 0) + width, width), rem(elem(new_head, 1) + height, height)}

    new_segments =
      if snake.pending_growth > 0 do
        [new_head | snake.segments]
      else
        [new_head | Enum.drop(snake.segments, -1)]
      end

    %{snake |
      segments: new_segments,
      pending_growth: max(0, snake.pending_growth - 1)
    }
  end

  def grow(snake, amount \\ 1) do
    %{snake | pending_growth: snake.pending_growth + amount}
  end

  def change_direction(snake, new_direction) when is_atom(new_direction) do
    if valid_direction_change?(snake.direction, new_direction) do
      {:ok, %{snake | direction: new_direction}}
    else
      {:error, :invalid_direction}
    end
  end

  def valid_direction_change?(current, new) do
    @opposites[current] != new
  end

  def head(%{segments: [head | _]}), do: head

  def body(%{segments: [_ | body]}), do: body

  def all_positions(%{segments: segments}), do: segments

  def collides_with_self?(%{segments: [head | body]}) do
    head in body
  end

  def collides_with?(snake, other_snake) when snake.id != other_snake.id do
    head(snake) in all_positions(other_snake)
  end
  def collides_with?(_, _), do: false

  def is_invincible?(snake) do
    System.monotonic_time(:millisecond) < snake.invincible_until
  end
end
```

**lib/snaker/game/apple.ex:**
```elixir
defmodule Snaker.Game.Apple do
  @moduledoc "Apple spawning and management"

  alias Snaker.Game.Grid

  @min_apples 3
  @growth_per_apple 3

  def spawn_if_needed(apples, occupied_positions, grid_dimensions) do
    if length(apples) < @min_apples do
      all_occupied = MapSet.union(occupied_positions, MapSet.new(apples))
      case Grid.find_safe_spawn(all_occupied, grid_dimensions) do
        nil -> apples
        position -> [position | apples]
      end
    else
      apples
    end
  end

  def check_eaten(apples, snake_head) do
    if snake_head in apples do
      {true, apples -- [snake_head]}
    else
      {false, apples}
    end
  end

  def growth_amount, do: @growth_per_apple
end
```
  </action>
  <verify>
1. `ls lib/snaker/game/` shows snake.ex, apple.ex, grid.ex
2. `mix compile` succeeds with no errors
3. Each module has @moduledoc
  </verify>
  <done>Game logic modules created: Snake (movement, collision), Apple (spawning), Grid (boundaries)</done>
</task>

<task type="auto">
  <name>Task 2: Create GameServer GenServer</name>
  <files>lib/snaker/game_server.ex</files>
  <action>
Create `lib/snaker/game_server.ex` - the authoritative game state GenServer with tick loop.

Key features per CONTEXT.md and RESEARCH.md:
- 100ms tick interval (10 ticks/second)
- Process.send_after pattern for tick scheduling
- Input buffer for rate limiting (first direction change per tick)
- Delta broadcasts via Phoenix.PubSub
- Full state on join, delta on tick

```elixir
defmodule Snaker.GameServer do
  @moduledoc """
  Authoritative game state server.

  Maintains single source of truth for all game state:
  - Snake positions, directions, segments
  - Apple positions
  - Player metadata

  Ticks every 100ms, broadcasting delta updates to all connected clients.
  """

  use GenServer
  require Logger

  alias Snaker.Game.{Snake, Apple, Grid}

  @tick_interval 100  # 10 ticks/second
  @first_names ["Jesse", "Vanessa", "George", "Henry", "Theresa", "Sean", "Sandra", "Penelope",
    "Samantha", "Ziggy", "Kirk", "Veronica", "Zoobadooba", "Tigger", "Zoomy-zoom"]
  @animals ["Kitten", "Fox", "Panda", "Tiger", "Giraffe", "Horse", "Pig", "Bird", "Squirrel", "Snake",
    "Pheasant", "Raccoon", "Leopard", "Goat", "Crocodile", "Armadillo", "Crow", "Donkey", "Ferret",
    "Lizard", "Coyote", "Duck", "Gorilla", "Goose", "Camel", "Weasel", "Heron", "Shark"]
  @adjectives ["Platonic", "Smoochy", "Squishy", "Thoughtless", "Amazing", "Unfathomable", "Inscrutible",
    "Immense", "Stoic", "Frivolous", "Smirking", "Dangerous", "Zazzy", "Laughing", "Incontrovertible"]
  @colours ["67a387", "e6194b", "3cb44b", "ffe119", "0082c8", "f58231", "911eb4",
    "46f0f0", "f032e6", "d2f53c", "fabebe", "008080", "e6beff", "aa6e28", "fffac8",
    "800000", "aaffc3", "808000", "ffd8b1"]

  # Client API

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  def join_game(player_id) do
    GenServer.call(__MODULE__, {:join, player_id})
  end

  def leave_game(player_id) do
    GenServer.cast(__MODULE__, {:leave, player_id})
  end

  def change_direction(player_id, direction) do
    GenServer.call(__MODULE__, {:change_direction, player_id, direction})
  end

  def get_full_state do
    GenServer.call(__MODULE__, :get_full_state)
  end

  # For testing
  def trigger_tick do
    send(__MODULE__, :tick)
  end

  # Server Callbacks

  @impl true
  def init(_opts) do
    state = %{
      snakes: %{},
      apples: [],
      grid: Grid.default_dimensions(),
      input_buffer: %{},
      next_player_id: 1,
      tick_count: 0
    }

    # Spawn initial apples
    state = spawn_initial_apples(state)

    schedule_tick()
    {:ok, state}
  end

  @impl true
  def handle_call({:join, _player_id}, _from, state) do
    # Generate player data
    player_id = state.next_player_id
    color = Enum.random(@colours)
    name = random_name()

    # Find safe spawn position
    occupied = get_all_occupied_positions(state)
    spawn_pos = Grid.find_safe_spawn(occupied, state.grid)

    snake = Snake.new(player_id, spawn_pos, color, name)

    new_state =
      state
      |> put_in([:snakes, player_id], snake)
      |> Map.update!(:next_player_id, &(&1 + 1))

    player_data = %{
      id: player_id,
      colour: color,
      name: name
    }

    full_state = serialize_full_state(new_state)

    Logger.debug("[GameServer] Player #{player_id} (#{name}) joined at #{inspect(spawn_pos)}")

    {:reply, {:ok, player_data, full_state}, new_state}
  end

  @impl true
  def handle_call({:change_direction, player_id, direction}, _from, state) do
    direction_atom = String.to_existing_atom(direction)

    # Rate limit: only accept first direction change per tick
    if Map.has_key?(state.input_buffer, player_id) do
      {:reply, {:error, :rate_limited}, state}
    else
      case Map.get(state.snakes, player_id) do
        nil ->
          {:reply, {:error, :player_not_found}, state}
        snake ->
          if Snake.valid_direction_change?(snake.direction, direction_atom) do
            new_state = put_in(state, [:input_buffer, player_id], direction_atom)
            {:reply, :ok, new_state}
          else
            {:reply, {:error, :invalid_direction}, state}
          end
      end
    end
  rescue
    ArgumentError ->
      {:reply, {:error, :invalid_direction}, state}
  end

  @impl true
  def handle_call(:get_full_state, _from, state) do
    {:reply, serialize_full_state(state), state}
  end

  @impl true
  def handle_cast({:leave, player_id}, state) do
    Logger.debug("[GameServer] Player #{player_id} left")

    new_state =
      state
      |> update_in([:snakes], &Map.delete(&1, player_id))
      |> update_in([:input_buffer], &Map.delete(&1, player_id))

    # Broadcast player removal
    Phoenix.PubSub.broadcast(Snaker.PubSub, "game:snake", {:player_left, player_id})

    {:noreply, new_state}
  end

  @impl true
  def handle_info(:tick, state) do
    old_state = state

    # 1. Apply buffered direction changes
    state = apply_input_buffer(state)

    # 2. Move all snakes
    state = move_all_snakes(state)

    # 3. Check collisions (death/respawn)
    state = check_collisions(state)

    # 4. Check apple eating
    state = check_apple_eating(state)

    # 5. Spawn apples if needed
    state = spawn_apples_if_needed(state)

    # 6. Clear input buffer
    state = %{state | input_buffer: %{}, tick_count: state.tick_count + 1}

    # 7. Calculate and broadcast delta
    delta = calculate_delta(old_state, state)
    broadcast_tick(delta)

    # Log tick in verbose mode (every 10 ticks = 1 second)
    if rem(state.tick_count, 10) == 0 do
      snake_count = map_size(state.snakes)
      apple_count = length(state.apples)
      Logger.debug("[GameServer] Tick #{state.tick_count}: #{snake_count} snakes, #{apple_count} apples")
    end

    schedule_tick()
    {:noreply, state}
  end

  # Private Helpers

  defp schedule_tick do
    Process.send_after(self(), :tick, @tick_interval)
  end

  defp apply_input_buffer(state) do
    Enum.reduce(state.input_buffer, state, fn {player_id, direction}, acc ->
      case Map.get(acc.snakes, player_id) do
        nil -> acc
        snake ->
          {:ok, updated_snake} = Snake.change_direction(snake, direction)
          put_in(acc, [:snakes, player_id], updated_snake)
      end
    end)
  end

  defp move_all_snakes(state) do
    new_snakes =
      state.snakes
      |> Enum.map(fn {id, snake} -> {id, Snake.move(snake, state.grid)} end)
      |> Map.new()

    %{state | snakes: new_snakes}
  end

  defp check_collisions(state) do
    snakes = state.snakes

    # Check each snake for collisions
    Enum.reduce(snakes, state, fn {player_id, snake}, acc ->
      if Snake.is_invincible?(snake) do
        acc
      else
        # Self collision
        self_collision = Snake.collides_with_self?(snake)

        # Collision with other snakes
        other_collision =
          acc.snakes
          |> Map.values()
          |> Enum.any?(fn other -> Snake.collides_with?(snake, other) end)

        if self_collision or other_collision do
          respawn_snake(acc, player_id)
        else
          acc
        end
      end
    end)
  end

  defp respawn_snake(state, player_id) do
    case Map.get(state.snakes, player_id) do
      nil -> state
      snake ->
        occupied = get_all_occupied_positions(state)
        spawn_pos = Grid.find_safe_spawn(occupied, state.grid)

        new_snake = %{snake |
          segments: [spawn_pos],
          direction: :right,
          pending_growth: 0,
          invincible_until: System.monotonic_time(:millisecond) + 1500
        }

        Logger.debug("[GameServer] Player #{player_id} died and respawned at #{inspect(spawn_pos)}")

        put_in(state, [:snakes, player_id], new_snake)
    end
  end

  defp check_apple_eating(state) do
    Enum.reduce(state.snakes, state, fn {player_id, snake}, acc ->
      head = Snake.head(snake)
      {eaten, remaining_apples} = Apple.check_eaten(acc.apples, head)

      if eaten do
        grown_snake = Snake.grow(snake, Apple.growth_amount())
        Logger.debug("[GameServer] Player #{player_id} ate apple at #{inspect(head)}")

        acc
        |> Map.put(:apples, remaining_apples)
        |> put_in([:snakes, player_id], grown_snake)
      else
        acc
      end
    end)
  end

  defp spawn_apples_if_needed(state) do
    occupied = get_all_occupied_positions(state)
    new_apples = Apple.spawn_if_needed(state.apples, occupied, state.grid)
    %{state | apples: new_apples}
  end

  defp spawn_initial_apples(state) do
    # Spawn apples until we have minimum count
    Enum.reduce(1..3, state, fn _, acc ->
      spawn_apples_if_needed(acc)
    end)
  end

  defp get_all_occupied_positions(state) do
    snake_positions =
      state.snakes
      |> Map.values()
      |> Enum.flat_map(&Snake.all_positions/1)
      |> MapSet.new()

    MapSet.union(snake_positions, MapSet.new(state.apples))
  end

  defp calculate_delta(_old_state, new_state) do
    # For now, send full positions each tick
    # Can optimize to true delta later if needed
    %{
      snakes: new_state.snakes |> Map.values() |> Enum.map(&serialize_snake/1),
      apples: new_state.apples
    }
  end

  defp broadcast_tick(delta) do
    Phoenix.PubSub.broadcast(Snaker.PubSub, "game:snake", {:tick, delta})
  end

  defp serialize_full_state(state) do
    %{
      snakes: state.snakes |> Map.values() |> Enum.map(&serialize_snake/1),
      apples: state.apples,
      grid: %{width: elem(state.grid, 0), height: elem(state.grid, 1)}
    }
  end

  defp serialize_snake(snake) do
    %{
      id: snake.id,
      segments: snake.segments,
      direction: snake.direction,
      color: snake.color,
      name: snake.name
    }
  end

  defp random_name do
    [name, adjective, animal] =
      [@first_names, @adjectives, @animals]
      |> Enum.map(&Enum.random(&1))
    "#{name} the #{adjective} #{animal}"
  end
end
```
  </action>
  <verify>
1. `mix compile` succeeds
2. File contains `defmodule Snaker.GameServer`
3. File contains `@tick_interval 100`
4. File contains `Process.send_after`
5. File contains `Phoenix.PubSub.broadcast`
  </verify>
  <done>GameServer GenServer created with tick loop, authoritative state, input buffering</done>
</task>

<task type="auto">
  <name>Task 3: Wire GameServer and update channel</name>
  <files>lib/snaker/application.ex, lib/snaker_web/channels/game_channel.ex, lib/snaker_web/channels/user_socket.ex</files>
  <action>
**lib/snaker/application.ex:**
Add GameServer to supervision tree (after PubSub, before Endpoint):

```elixir
children = [
  {Phoenix.PubSub, name: Snaker.PubSub},
  Snaker.GameServer,  # Add this line
  SnakerWeb.Endpoint,
  {Snaker.Worker, nil}  # Keep Worker for now (used by UserSocket)
]
```

**lib/snaker_web/channels/user_socket.ex:**
Update connect to not create player (GameServer handles that now):

```elixir
def connect(_params, socket, _connect_info) do
  {:ok, socket}
end
```

Note: Player creation moved to GameServer.join_game/1 called from channel join.

**lib/snaker_web/channels/game_channel.ex:**
Update to use GameServer for all game state:

```elixir
defmodule SnakerWeb.GameChannel do
  use Phoenix.Channel
  require Logger
  alias Snaker.GameServer

  def join("game:snake", _message, socket) do
    # Subscribe to game broadcasts
    Phoenix.PubSub.subscribe(Snaker.PubSub, "game:snake")

    # Join game and get initial state
    case GameServer.join_game(socket.id || :rand.uniform(1_000_000)) do
      {:ok, player_data, full_state} ->
        socket = assign(socket, :player, player_data)
        send(self(), :after_join)
        {:ok, %{player: player_data, game_state: full_state}, socket}
      {:error, reason} ->
        {:error, %{reason: reason}}
    end
  end

  def handle_info(:after_join, socket) do
    broadcast!(socket, "player:join", %{player: socket.assigns.player})
    {:noreply, socket}
  end

  def handle_info({:tick, delta}, socket) do
    push(socket, "tick", delta)
    {:noreply, socket}
  end

  def handle_info({:player_left, player_id}, socket) do
    push(socket, "player:leave", %{player_id: player_id})
    {:noreply, socket}
  end

  def terminate(_reason, socket) do
    if socket.assigns[:player] do
      GameServer.leave_game(socket.assigns.player.id)
      broadcast!(socket, "player:leave", %{player: socket.assigns.player})
    end
    :ok
  end

  def handle_in("player:change_direction", %{"direction" => direction}, socket) do
    player_id = socket.assigns.player.id

    case GameServer.change_direction(player_id, direction) do
      :ok -> {:reply, :ok, socket}
      {:error, reason} -> {:reply, {:error, %{reason: reason}}, socket}
    end
  end

  # Remove handle_out - no longer needed since we use PubSub broadcasts
end
```
  </action>
  <verify>
1. `mix compile` succeeds
2. `grep "Snaker.GameServer" lib/snaker/application.ex` returns match
3. `grep "GameServer.join_game" lib/snaker_web/channels/game_channel.ex` returns match
4. Start server: `mix phx.server` - should log tick events every second
  </verify>
  <done>GameServer in supervision tree, channel uses GameServer for all game operations</done>
</task>

</tasks>

<verification>
Run these commands to verify phase completion:

```bash
# Compile everything
mix compile

# Start server and watch logs (should see tick events)
# In one terminal:
mix phx.server

# Should see logs like:
# [debug] [GameServer] Tick 10: 0 snakes, 3 apples
# [debug] [GameServer] Tick 20: 0 snakes, 3 apples

# Check GameServer is running
# In another terminal (iex -S mix):
# Process.whereis(Snaker.GameServer) |> Process.alive?()
```

Expected output:
- Server starts without errors
- Tick events logged every ~1 second (every 10 ticks)
- GameServer process is alive
</verification>

<success_criteria>
1. GameServer GenServer ticks every 100ms
2. Tick events appear in console logs (in dev mode, every 10 ticks / 1 second)
3. GameServer maintains snakes and apples state
4. Channel join creates snake via GameServer
5. Channel terminate removes snake via GameServer
6. Direction changes validated (no 180-degree reversals)
7. Server starts and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-modernization/01-03-SUMMARY.md`
</output>
