---
phase: 06-host-client-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - assets/src/Network/Protocol.elm
  - assets/src/Network/HostGame.elm
  - assets/js/peerjs-ports.ts
  - assets/src/Ports.elm
  - assets/src/Main.elm
autonomous: true

must_haves:
  truths:
    - "Host runs game loop when P2P connected"
    - "Host broadcasts game state to all connected peers"
    - "Multiple snakes can exist in game state"
  artifacts:
    - path: "assets/src/Network/Protocol.elm"
      provides: "Game message types and JSON encoders/decoders"
      exports: ["GameMessage", "encodeGameMessage", "decodeGameMessage", "encodeStateSync", "decodeStateSync", "encodeInput", "decodeInput"]
    - path: "assets/src/Network/HostGame.elm"
      provides: "Multi-player host game loop"
      exports: ["HostGameState", "init", "tick", "addPlayer", "removePlayer"]
    - path: "assets/js/peerjs-ports.ts"
      provides: "Broadcast to all connected peers"
      contains: "broadcastGameState"
  key_links:
    - from: "assets/src/Network/HostGame.elm"
      to: "assets/src/Main.elm"
      via: "HostGame.tick called on Time.every when P2P connected as host"
      pattern: "HostGame\\.tick"
    - from: "assets/src/Main.elm"
      to: "assets/js/peerjs-ports.ts"
      via: "Ports.broadcastGameState sends encoded state"
      pattern: "Ports\\.broadcastGameState"
    - from: "assets/js/peerjs-ports.ts"
      to: "PeerJS connections"
      via: "conn.send for all connections in Map"
      pattern: "connections\\.forEach.*send"
---

<objective>
Implement host-authoritative multiplayer game loop with state broadcasting over P2P connections.

Purpose: Enable the host to run the authoritative game simulation and broadcast synchronized state to all connected clients. This is the foundation for real-time multiplayer gameplay.

Output: Network/Protocol.elm (message types), Network/HostGame.elm (multi-player game loop), updated peerjs-ports.ts (broadcast), new ports for game state sync.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-host-client-integration/06-CONTEXT.md
@.planning/phases/06-host-client-integration/06-RESEARCH.md

# Existing implementation to extend
@assets/src/LocalGame.elm
@assets/src/Snake.elm
@assets/js/peerjs-ports.ts
@assets/src/Ports.elm
@assets/src/Main.elm
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Network/Protocol.elm with message types and codecs</name>
  <files>assets/src/Network/Protocol.elm</files>
  <action>
Create new module `Network/Protocol.elm` defining the P2P game message protocol.

**Message types to define:**

```elm
type GameMessage
    = StateSync StateSyncPayload    -- Host -> Client: full/delta state
    | InputMessage InputPayload      -- Client -> Host: direction input
    | PlayerJoin PlayerJoinPayload   -- Bidirectional: player joining
    | PlayerLeave PlayerLeavePayload -- Bidirectional: player leaving

type alias StateSyncPayload =
    { snakes : List SnakeState
    , apples : List AppleState
    , scores : Dict String Int
    , tick : Int
    , isFull : Bool  -- True for full sync, False for delta
    }

type alias SnakeState =
    { id : String
    , body : List Position
    , direction : Direction
    , color : String
    , name : String
    , isInvincible : Bool
    }

type alias AppleState =
    { position : Position
    , expiresAtTick : Int
    }

type alias InputPayload =
    { playerId : String
    , direction : Direction
    , tick : Int  -- Client's local tick for ordering
    }

type alias PlayerJoinPayload =
    { playerId : String
    , name : String
    }

type alias PlayerLeavePayload =
    { playerId : String
    }
```

**JSON encoders to implement:**
- `encodeGameMessage : GameMessage -> JE.Value`
- `encodeStateSync : StateSyncPayload -> JE.Value`
- `encodeInput : InputPayload -> JE.Value`

**JSON decoders to implement:**
- `decodeGameMessage : JD.Decoder GameMessage`
- `decodeStateSync : JD.Decoder StateSyncPayload`
- `decodeInput : JD.Decoder InputPayload`

Use lowercase snake_case for JSON field names to match existing conventions (e.g., `is_invincible`, `expires_at_tick`).

Import Dict from elm/core for scores tracking.
  </action>
  <verify>
Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Network/Protocol.elm --output=/dev/null` compiles without errors.
  </verify>
  <done>
Protocol.elm exists with GameMessage type, all payload types, encoders and decoders. Compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Network/HostGame.elm multi-player game loop</name>
  <files>assets/src/Network/HostGame.elm</files>
  <action>
Create new module `Network/HostGame.elm` that extends LocalGame pattern for multi-player hosting.

**Key differences from LocalGame:**
- Multiple snakes in a Dict (keyed by playerId)
- Host's own snake is one of the snakes (id matches host's peerId)
- Each snake has individual invincibility tracking
- Collision detection between all snakes (not just self)

**Types to define:**

```elm
type alias HostGameState =
    { snakes : Dict String SnakeData
    , apples : List Apple
    , grid : { width : Int, height : Int }
    , scores : Dict String Int
    , currentTick : Int
    , hostId : String  -- Host's own player ID
    , pendingInputs : Dict String Direction  -- Buffered inputs per player
    , disconnectedPlayers : Dict String Int  -- playerId -> disconnectTick (for grace period)
    }

type alias SnakeData =
    { snake : Snake
    , invincibleUntilTick : Int
    , needsRespawn : Bool
    }

type alias TickResult =
    { state : HostGameState
    , needsAppleSpawn : Int
    , expiredApples : List Apple
    , stateSync : StateSyncPayload  -- For broadcasting
    }
```

**Functions to implement:**

1. `init : String -> Random.Generator HostGameState` - Initialize with host as first player
2. `addPlayer : String -> String -> Position -> HostGameState -> HostGameState` - Add new player with spawn position
3. `removePlayer : String -> HostGameState -> HostGameState` - Mark player as disconnected (start grace period)
4. `confirmRemovePlayer : String -> HostGameState -> HostGameState` - Actually remove after grace period
5. `bufferInput : String -> Direction -> HostGameState -> HostGameState` - Buffer input for a player
6. `tick : HostGameState -> TickResult` - Process one game tick:
   - Apply all buffered inputs
   - Move all snakes
   - Check collisions (self and with others)
   - Handle respawns for collided snakes
   - Check apple eating (any snake can eat)
   - Check apple expiration
   - Generate StateSyncPayload
   - Full sync every 50 ticks (`isFull = currentTick % 50 == 0`)

7. `toStateSyncPayload : Bool -> HostGameState -> StateSyncPayload` - Convert state for broadcasting

**Color palette for random snake colors (12 distinct colors):**
```elm
snakeColors : List String
snakeColors =
    [ "e57373", "f06292", "ba68c8", "9575cd"  -- reds/pinks/purples
    , "64b5f6", "4fc3f7", "4dd0e1", "4db6ac"  -- blues/teals
    , "81c784", "aed581", "dce775", "ffb74d"  -- greens/yellows/orange
    ]
```

Use `modBy (List.length snakeColors) (hash playerId)` for deterministic color assignment.

Handle disconnected players: during grace period (30 ticks = 3 seconds), snake continues moving in last direction but is marked as ghosted.
  </action>
  <verify>
Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Network/HostGame.elm --output=/dev/null` compiles without errors.
  </verify>
  <done>
HostGame.elm exists with multi-snake game loop. Supports add/remove players, tick processing, collision between snakes, and generates StateSyncPayload. Compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add broadcast ports and wire host game loop in Main.elm</name>
  <files>assets/js/peerjs-ports.ts, assets/src/Ports.elm, assets/src/Main.elm</files>
  <action>
**1. Update peerjs-ports.ts with broadcast functionality:**

Add to P2PPorts interface:
```typescript
// New outgoing port
broadcastGameState: { subscribe: (callback: (data: string) => void) => void };

// New incoming ports
receiveGameStateP2P: { send: (data: string) => void };
receiveInputP2P: { send: (data: string) => void };
```

Add broadcast subscription:
```typescript
app.ports.broadcastGameState.subscribe((jsonData: string) => {
  connections.forEach((conn) => {
    if (conn.open) {
      conn.send({ type: 'state', data: jsonData });
    }
  });
});
```

Update data handlers in connection event listeners:
```typescript
conn.on('data', (data: any) => {
  if (data.type === 'state') {
    app.ports.receiveGameStateP2P.send(data.data);
  } else if (data.type === 'input') {
    app.ports.receiveInputP2P.send(data.data);
  }
});
```

**2. Update Ports.elm with new ports:**

Add outgoing:
```elm
port broadcastGameState : String -> Cmd msg
port sendInputP2P : String -> Cmd msg
```

Add incoming:
```elm
port receiveGameStateP2P : (String -> msg) -> Sub msg
port receiveInputP2P : (String -> msg) -> Sub msg
```

**3. Update Main.elm:**

Add imports:
```elm
import Network.HostGame as HostGame exposing (HostGameState)
import Network.Protocol as Protocol
import Dict
```

Add to Model:
```elm
, hostGame : Maybe HostGameState
, myPeerId : Maybe String  -- Our peer ID (set when room created or joined)
```

Add new Msg variants:
```elm
| InitHostGame HostGameState
| HostTick Time.Posix
| NewHostSpawnPosition String Position  -- playerId, position
| NewHostApplePosition Position
| GotInputP2P String  -- JSON string from port
```

Update GotRoomCreated handler:
- Set `myPeerId = Just roomCode`
- Initialize HostGame with host's ID: `Random.generate InitHostGame (HostGame.init roomCode)`

Update subscriptions:
- When `P2PConnected Host _`, use `Time.every 100 HostTick` instead of regular Tick
- Add `Ports.receiveInputP2P GotInputP2P`

Add HostTick handler:
```elm
HostTick _ ->
    case model.hostGame of
        Just hostState ->
            let
                tickResult = HostGame.tick hostState
                stateJson = Protocol.encodeStateSync tickResult.stateSync |> JE.encode 0
            in
            ( { model | hostGame = Just tickResult.state }
            , Cmd.batch
                [ Ports.broadcastGameState stateJson
                , handleAppleSpawns tickResult  -- Similar to existing logic
                ]
            )
        Nothing ->
            ( model, Cmd.none )
```

Add GotInputP2P handler:
- Decode input message
- Apply to hostGame via `HostGame.bufferInput`

Update view to render hostGame when in host mode.
  </action>
  <verify>
1. Run `cd /Users/julian/code/elm/snaker-elm/assets && npm run build` - should complete without errors
2. Run `cd /Users/julian/code/elm/snaker-elm/assets && npx tsc --noEmit` - TypeScript compiles (ignore pre-existing socket.ts warnings)
3. Start app with `cd /Users/julian/code/elm/snaker-elm && mix phx.server`, create room - should see snake moving (single player host mode working)
  </verify>
  <done>
Host game loop runs when P2P connected as host. State is broadcast to all connections on each tick. Build completes successfully. Creating a room shows functional snake game.
  </done>
</task>

</tasks>

<verification>
1. All files compile: `cd /Users/julian/code/elm/snaker-elm/assets && npm run build`
2. Create room in browser -> game starts with host's snake moving
3. Console shows "broadcastGameState" being called every 100ms tick
4. Network/Protocol.elm and Network/HostGame.elm modules exist and export required types
</verification>

<success_criteria>
- Protocol.elm defines GameMessage and all payload types with encoders/decoders
- HostGame.elm implements multi-snake game loop with tick, addPlayer, removePlayer
- peerjs-ports.ts broadcasts state to all connections
- Main.elm runs HostGame.tick when P2P connected as host
- Host creating a room sees working snake game (single player initially)
</success_criteria>

<output>
After completion, create `.planning/phases/06-host-client-integration/06-01-SUMMARY.md`
</output>
