---
phase: 06-host-client-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - assets/src/Network/ClientGame.elm
  - assets/js/peerjs-ports.ts
  - assets/src/Ports.elm
  - assets/src/Main.elm
  - assets/css/app.css
autonomous: false

must_haves:
  truths:
    - "Client receives game state from host and renders it"
    - "Client sends direction input to host"
    - "New player joining mid-game sees all existing snakes and can play immediately"
    - "Player leaving is removed from all peers' game state"
    - "Own snake has visual distinction (glow effect)"
  artifacts:
    - path: "assets/src/Network/ClientGame.elm"
      provides: "Client-side state management and interpolation"
      exports: ["ClientGameState", "applyHostState", "bufferLocalInput", "getDisplayState"]
    - path: "assets/css/app.css"
      provides: "Visual styling for multiplayer snakes"
      contains: "snake.you"
  key_links:
    - from: "assets/src/Main.elm"
      to: "assets/src/Network/ClientGame.elm"
      via: "ClientGame.applyHostState when receiving state from host"
      pattern: "ClientGame\\.applyHostState"
    - from: "assets/src/Main.elm"
      to: "assets/js/peerjs-ports.ts"
      via: "Ports.sendInputP2P sends direction to host"
      pattern: "Ports\\.sendInputP2P"
    - from: "assets/js/peerjs-ports.ts"
      to: "Host connection"
      via: "hostConnection.send for input messages"
      pattern: "hostConnection.*send.*input"
---

<objective>
Complete P2P multiplayer by implementing client state rendering, input forwarding, player join/leave handling, and visual polish.

Purpose: Enable clients to receive and render the host's authoritative game state, send inputs back, and create a polished multiplayer experience with visual feedback.

Output: Network/ClientGame.elm (client state), updated Main.elm (client mode), input forwarding in peerjs-ports.ts, CSS for multiplayer visuals, functional 2+ player P2P gameplay.
</objective>

<execution_context>
@/Users/julian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-host-client-integration/06-CONTEXT.md
@.planning/phases/06-host-client-integration/06-RESEARCH.md
@.planning/phases/06-host-client-integration/06-01-SUMMARY.md

# Files modified in Plan 01
@assets/src/Network/Protocol.elm
@assets/src/Network/HostGame.elm
@assets/js/peerjs-ports.ts
@assets/src/Ports.elm
@assets/src/Main.elm
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Network/ClientGame.elm for client-side state</name>
  <files>assets/src/Network/ClientGame.elm</files>
  <action>
Create new module `Network/ClientGame.elm` for client-side game state management.

**Key responsibilities:**
- Store last received host state
- Apply optimistic local input (snake turns immediately)
- Interpolate toward host state when corrections needed
- Track which snake is "ours" for visual distinction

**Types to define:**

```elm
type alias ClientGameState =
    { snakes : Dict String SnakeState  -- From host
    , apples : List AppleState
    , scores : Dict String Int
    , lastHostTick : Int
    , myId : String  -- Our player ID
    , pendingInput : Maybe Direction  -- Optimistic local input
    , lastAppliedInput : Maybe Direction  -- For interpolation
    }

type alias SnakeState =
    { body : List Position
    , direction : Direction
    , color : String
    , name : String
    , isInvincible : Bool
    , isDisconnected : Bool  -- For ghosted rendering
    }
```

**Functions to implement:**

1. `init : String -> ClientGameState` - Initialize with our player ID
2. `applyHostState : StateSyncPayload -> ClientGameState -> ClientGameState`
   - Replace snakes/apples/scores with host data
   - Update lastHostTick
   - Clear pendingInput if it was applied

3. `bufferLocalInput : Direction -> ClientGameState -> ClientGameState`
   - Store in pendingInput for optimistic display
   - Store in lastAppliedInput for reference

4. `getMySnake : ClientGameState -> Maybe SnakeState`
   - Lookup snake by myId
   - Apply pendingInput optimistically to direction if present

5. `toGameState : ClientGameState -> { snakes : List Snake, apples : List AppleState, gridWidth : Int, gridHeight : Int }`
   - Convert to format compatible with Board.view
   - Mark our snake with special indicator

**Optimistic input handling:**
When we buffer a local input, immediately update the local snake's direction for display. When host state arrives, if our snake's direction matches our pending input, clear it (input was applied). If different, smoothly transition (host authority wins).

For this phase, keep interpolation simple: just use host state directly. Smooth interpolation deferred if needed.
  </action>
  <verify>
Run `cd /Users/julian/code/elm/snaker-elm/assets && npx elm make src/Network/ClientGame.elm --output=/dev/null` compiles without errors.
  </verify>
  <done>
ClientGame.elm exists with state management for clients. Supports applying host state, buffering optimistic input, and converting to renderable format. Compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire client mode in Main.elm and add input forwarding</name>
  <files>assets/src/Main.elm, assets/js/peerjs-ports.ts, assets/src/Ports.elm</files>
  <action>
**1. Update peerjs-ports.ts for client input sending:**

Add tracking for host connection on client side:
```typescript
let hostConnection: DataConnection | null = null;
```

In joinRoom handler, after connection opens:
```typescript
conn.on('open', () => {
  hostConnection = conn;  // Store reference for sending input
  // ... existing code
});

conn.on('close', () => {
  hostConnection = null;
  // ... existing code
});
```

Add sendInputP2P subscription:
```typescript
app.ports.sendInputP2P.subscribe((jsonData: string) => {
  if (hostConnection && hostConnection.open) {
    hostConnection.send({ type: 'input', data: jsonData });
  }
});
```

**2. Update Main.elm for client mode:**

Add to Model:
```elm
, clientGame : Maybe ClientGameState
```

Add new Msg variants:
```elm
| GotGameStateP2P String  -- JSON string from host
```

Update GotPeerConnected for client:
- Set `myPeerId = Just generatedPeerId` (need to capture from peer.on('open'))
- Initialize ClientGame: `clientGame = Just (ClientGame.init peerId)`

**NOTE:** Need to pass client's peerId from JS. Update peerConnected port data:
```typescript
// For client, include the client's own peerId
app.ports.peerConnected.send({
  role: 'client',
  roomCode: roomCode,
  myPeerId: peer!.id  // Add this field
});
```

Update subscriptions:
- When `P2PConnected Client _`, subscribe to `Ports.receiveGameStateP2P GotGameStateP2P`
- NO tick subscription for client (host drives the tick)

Add GotGameStateP2P handler:
```elm
GotGameStateP2P jsonStr ->
    case JD.decodeString Protocol.decodeStateSync jsonStr of
        Ok stateSync ->
            case model.clientGame of
                Just clientState ->
                    ( { model | clientGame = Just (ClientGame.applyHostState stateSync clientState) }
                    , Cmd.none
                    )
                Nothing ->
                    ( model, Cmd.none )
        Err _ ->
            ( model, Cmd.none )
```

Update KeyPressed handler for client mode:
```elm
-- In P2PConnected Client mode:
case model.clientGame of
    Just clientState ->
        let
            newClientState = ClientGame.bufferLocalInput dir clientState
            inputPayload = Protocol.encodeInput
                { playerId = clientState.myId
                , direction = dir
                , tick = clientState.lastHostTick
                }
            inputJson = JE.encode 0 inputPayload
        in
        ( { model | clientGame = Just newClientState }
        , Ports.sendInputP2P inputJson
        )
    Nothing ->
        ( model, Cmd.none )
```

**3. Handle player join on host side:**

When host receives GotPeerConnected (a client connected):
```elm
GotPeerConnected data ->
    case data.role of
        Host ->
            -- A client connected to us (we are host)
            case model.hostGame of
                Just hostState ->
                    -- Generate spawn position and add player
                    ( model
                    , Random.generate (NewPlayerSpawn data.peerId)
                        (randomSafePosition hostState)
                    )
                Nothing ->
                    ( model, Cmd.none )
        Client ->
            -- We connected to host
            ( { model
                | p2pState = P2PConnected Client data.roomCode
                , clientGame = Just (ClientGame.init data.myPeerId)
                , myPeerId = Just data.myPeerId
              }
            , Cmd.none
            )
```

Add NewPlayerSpawn handler:
```elm
NewPlayerSpawn peerId position ->
    case model.hostGame of
        Just hostState ->
            let
                newState = HostGame.addPlayer peerId ("Player " ++ String.left 4 peerId) position hostState
            in
            ( { model | hostGame = Just newState }
            , Cmd.none
            )
        Nothing ->
            ( model, Cmd.none )
```

**4. Handle player disconnect:**

Update GotPeerDisconnected on host:
```elm
GotPeerDisconnected peerId ->
    case model.hostGame of
        Just hostState ->
            let
                newState = HostGame.removePlayer peerId hostState
            in
            ( { model | hostGame = Just newState }
            , Cmd.none
            )
        Nothing ->
            -- Client mode - we got disconnected
            ( { model
                | p2pState = P2PNotConnected
                , clientGame = Nothing
                , notification = Just "Disconnected from host"
              }
            , Process.sleep 3000 |> Task.perform (\_ -> ClearNotification)
            )
```

**5. Update view to render correct game:**

```elm
viewGame model =
    case model.p2pState of
        P2PConnected Host _ ->
            case model.hostGame of
                Just hostState ->
                    viewHostGame hostState model.myPeerId
                Nothing ->
                    text "Initializing host game..."

        P2PConnected Client _ ->
            case model.clientGame of
                Just clientState ->
                    viewClientGame clientState
                Nothing ->
                    text "Waiting for game state..."

        _ ->
            -- Local mode or not connected
            viewLocalGame model
```
  </action>
  <verify>
1. Run `cd /Users/julian/code/elm/snaker-elm/assets && npm run build` - completes without errors
2. Run `cd /Users/julian/code/elm/snaker-elm/assets && npx tsc --noEmit` - TypeScript compiles
3. Open two browser tabs, create room in one, join in other - both should see snakes
4. Arrow keys in client tab should move client's snake (visible in both tabs)
  </verify>
  <done>
Client mode receives and renders host state. Arrow keys in client send input to host. Host processes client input and broadcasts updated state. Two browser tabs can play together.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add visual polish for multiplayer</name>
  <files>assets/css/app.css, assets/src/View/Board.elm</files>
  <action>
**1. Update app.css with multiplayer visual styles:**

Add glow effect for player's own snake:
```css
/* Player's own snake has glow effect */
.snake.you .snake-head circle:first-child {
  filter: drop-shadow(0 0 6px currentColor);
  stroke: white;
  stroke-width: 2;
}

.snake.you .snake-segment {
  filter: drop-shadow(0 0 4px currentColor);
}

/* Disconnected player snake (ghosted) */
.snake.disconnected {
  opacity: 0.4;
}

.snake.disconnected .snake-head,
.snake.disconnected .snake-segment {
  filter: grayscale(50%);
}

/* Player name labels (optional enhancement) */
.snake-label {
  font-size: 10px;
  fill: white;
  text-anchor: middle;
  pointer-events: none;
}
```

**2. Update View/Board.elm to mark player's snake:**

The existing code already adds "you" class when `isYou` is true. Verify this works with the new multiplayer snake rendering.

Add disconnected class support:
```elm
renderSnake : Snake -> Maybe String -> Svg msg
renderSnake snake maybePlayerId =
    let
        isYou = Just snake.id == maybePlayerId

        classes =
            [ "snake"
            , if snake.isInvincible then "invincible" else ""
            , if snake.state == "dying" then "dying" else ""
            , if snake.state == "disconnected" then "disconnected" else ""
            , if isYou then "you" else ""
            ]
            |> List.filter (not << String.isEmpty)
            |> String.join " "
    in
    g [ svgClass classes ] (renderSnakeBody snake)
```

**3. Add "Player joined" / "Player left" notifications:**

These are already handled via the existing notification system. Verify they work by updating the host's GotPeerConnected and GotPeerDisconnected handlers to set notifications:

In GotPeerConnected (when we're host and client connects):
```elm
-- After adding player
( { model
    | hostGame = Just newState
    , notification = Just ("Player joined: " ++ String.left 4 peerId)
  }
, Process.sleep 3000 |> Task.perform (\_ -> ClearNotification)
)
```

In GotPeerDisconnected (when client leaves):
```elm
-- After removing player
( { model
    | hostGame = Just newState
    , notification = Just "Player left"
  }
, Process.sleep 3000 |> Task.perform (\_ -> ClearNotification)
)
```

**4. Update scoreboard for top 3 only:**

In View/Scoreboard.elm (or in Main.elm view), limit displayed scores:
```elm
viewScoreboard : List Snake -> Maybe String -> Html msg
viewScoreboard snakes maybePlayerId =
    let
        -- Sort by score descending, take top 3
        topPlayers =
            snakes
                |> List.sortBy (\s -> negate s.score)  -- Descending
                |> List.take 3
    in
    -- ... render top 3 only
```

Note: Snake type may need a score field, or use the scores Dict from game state.
  </action>
  <verify>
1. Run `cd /Users/julian/code/elm/snaker-elm/assets && npm run build` - completes without errors
2. Open two browser tabs, both snakes visible
3. Your own snake has glow/outline effect
4. "Player joined" notification appears when second player connects
5. If one player disconnects, their snake appears ghosted before removal
  </verify>
  <done>
Player's own snake has visual glow effect. Disconnected players show ghosted. Join/leave notifications appear. Scoreboard shows top 3.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete P2P multiplayer gameplay with host-authoritative game loop, client state rendering, input forwarding, and visual polish.
  </what-built>
  <how-to-verify>
1. Start the app: `cd /Users/julian/code/elm/snaker-elm && mix phx.server`
2. Open http://localhost:4000 in two browser windows side by side

**Test Create/Join flow:**
3. In Window 1: Click "Create" - room code appears
4. In Window 2: Enter the 4-letter code - should auto-connect at 4 characters
5. Both windows should show TWO snakes (different colors)

**Test gameplay:**
6. Press arrow keys in Window 1 - host snake should move in both windows
7. Press arrow keys in Window 2 - client snake should move in both windows
8. Snakes eating apples should grow and score should increment
9. Collision between snakes or self should cause respawn with invincibility

**Test visual polish:**
10. Your own snake should have a glow/outline effect distinguishing it
11. When Window 2 joins, "Player joined" notification should appear in Window 1

**Test disconnect:**
12. Close Window 2 - Window 1 should show "Player left" notification
13. After ~3 seconds, the disconnected player's snake should disappear

Expected: Full multiplayer snake game working across two browser windows with synchronized state.
  </how-to-verify>
  <resume-signal>Type "approved" if multiplayer works, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. All files compile: `cd /Users/julian/code/elm/snaker-elm/assets && npm run build`
2. Two browser tabs can create/join room and see each other's snakes
3. Arrow keys control snakes with input going host -> broadcast to all
4. Player's own snake has visual distinction (glow)
5. Join/leave notifications appear
6. Disconnect shows ghosted snake briefly before removal
</verification>

<success_criteria>
- HOST-01: First peer to create room becomes host (verified: host runs game loop)
- HOST-02: Host runs game loop and broadcasts state (verified: state sync working)
- HOST-03: Non-host peers send input to host only (verified: input forwarding)
- HOST-04: Non-host peers render state from host (verified: client rendering)
- HOST-05: New player joining mid-game receives full state (verified: join flow)
- HOST-06: Player leaving is removed from game state (verified: disconnect handling)
- Two browser windows can play multiplayer snake together
</success_criteria>

<output>
After completion, create `.planning/phases/06-host-client-integration/06-02-SUMMARY.md`
</output>
